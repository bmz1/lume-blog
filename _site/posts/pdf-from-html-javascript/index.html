<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generating PDF from HTML with JavaScript</title>
    <meta name="description" content="In this article I’m going to show how you can generate a PDF document from a heavily styled React page using Puppeteer, headless Chrome &amp; Docker">
    <meta name="keywords" content="HTML, CSS, JavaScript, Typescript, Docker, Node.js, devops, React, framework, full-stack">
    <meta name="author" content="Mate Boer (BMZ)">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link rel="stylesheet" href="/pagefind/pagefind-ui.css"><link href="https://fonts.googleapis.com/css2?family=Montserrat&amp;family=PT+Serif&amp;display=swap" rel="stylesheet">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="stylesheet" href="/styles.css">
  <meta property="og:type" content="website">
<meta property="og:title" content="Generating PDF from HTML with JavaScript">
<meta property="og:description" content="In this article I’m going to show how you can generate a PDF document from a heavily styled React page using Puppeteer, headless Chrome &amp; Docker.">
<meta property="og:url" content="http://localhost:3000/posts/pdf-from-html-javascript/">
<meta property="og:image" content="http://localhost:3000/img/pdf.webp">
<meta name="twitter:title" content="Generating PDF from HTML with JavaScript">
<meta name="twitter:description" content="In this article I’m going to show how you can generate a PDF document from a heavily styled React page using Puppeteer, headless Chrome &amp; Docker.">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:3000/img/pdf.webp">
<meta itemprop="name" content="Generating PDF from HTML with JavaScript">
<meta itemprop="description" content="In this article I’m going to show how you can generate a PDF document from a heavily styled React page using Puppeteer, headless Chrome &amp; Docker.">
<meta itemprop="image" content="http://localhost:3000/img/pdf.webp">
<meta name="description" content="In this article I’m going to show how you can generate a PDF document from a heavily styled React page using Puppeteer, headless Chrome &amp; Docker.">
<style>*, ::before, ::after {
  -webkit-box-sizing: border-box;
  box-sizing: border-box;
  border-width: 0;
  border-style: solid;
  border-color: #e5e7eb;
}
* {
  --tw-ring-inset: var(--tw-empty,/*!*/ /*!*/);
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgba(59, 130, 246, 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
}
:root {
  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;
}
:-moz-focusring {
  outline: 1px dotted ButtonText;
}
:-moz-ui-invalid {
  box-shadow: none;
}
::moz-focus-inner {
  border-style: none;
  padding: 0;
}
::-webkit-inner-spin-button, ::-webkit-outer-spin-button {
  height: auto;
}
::-webkit-search-decoration {
  -webkit-appearance: none;
}
::-webkit-file-upload-button {
  -webkit-appearance: button;
  font: inherit;
}
[type='search'] {
  -webkit-appearance: textfield;
  outline-offset: -2px;
}
abbr[title] {
  -webkit-text-decoration: underline dotted;
  text-decoration: underline dotted;
}
a {
  color: inherit;
  text-decoration: inherit;
}
body {
  margin: 0;
  font-family: inherit;
  line-height: inherit;
}
html {
  -webkit-text-size-adjust: 100%;
  font-family: ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
  line-height: 1.5;
}
hr {
  height: 0;
  color: inherit;
  border-top-width: 1px;
}
h1, p, h2, pre, h3, hr {
  margin: 0;
}
h1, h2, h3 {
  font-size: inherit;
  font-weight: inherit;
}
pre, code {
  font-size: 1em;
  font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
}
strong {
  font-weight: bolder;
}
ul {
  list-style: none;
  margin: 0;
  padding: 0;
}
.bg-black {
  --tw-bg-opacity: 1;
  background-color: rgba(0, 0, 0, var(--tw-bg-opacity));
}
.flex {
  display: -webkit-box;
  display: -ms-flexbox;
  display: -webkit-flex;
  display: flex;
}
.flex-col {
  -webkit-box-orient: vertical;
  -webkit-box-direction: normal;
  -ms-flex-direction: column;
  -webkit-flex-direction: column;
  flex-direction: column;
}
.flex-wrap {
  -ms-flex-wrap: wrap;
  -webkit-flex-wrap: wrap;
  flex-wrap: wrap;
}
.items-center {
  -webkit-box-align: center;
  -ms-flex-align: center;
  -webkit-align-items: center;
  align-items: center;
}
.font-bold {
  font-weight: 700;
}
.h-full {
  height: 100%;
}
.h-16 {
  height: 4rem;
}
.h-0 {
  height: 0px;
}
.text-lg {
  font-size: 1.125rem;
  line-height: 1.75rem;
}
.text-2xl {
  font-size: 1.5rem;
  line-height: 2rem;
}
.leading-10 {
  line-height: 2.5rem;
}
.ml-auto {
  margin-left: auto;
}
.mt-10 {
  margin-top: 2.5rem;
}
.max-w-3xl {
  max-width: 48rem;
}
.p-8 {
  padding: 2rem;
}
.p-2 {
  padding: 0.5rem;
}
.p-1 {
  padding: 0.25rem;
}
.px-4 {
  padding-left: 1rem;
  padding-right: 1rem;
}
.text-white {
  --tw-text-opacity: 1;
  color: rgba(255, 255, 255, var(--tw-text-opacity));
}
.tracking-tight {
  letter-spacing: -0.025em;
}
.invisible {
  visibility: hidden;
}
.w-full {
  width: 100%;
}
.w-0 {
  width: 0px;
}
.gap-x-8 {
  -webkit-column-gap: 2rem;
  -moz-column-gap: 2rem;
  grid-column-gap: 2rem;
  column-gap: 2rem;
}
.gap-y-4 {
  -webkit-row-gap: 1rem;
  -moz-row-gap: 1rem;
  grid-row-gap: 1rem;
  row-gap: 1rem;
}
@media (min-width: 640px) {
  .sm\:invisible {
    visibility: hidden;
  }
  .sm\:w-0 {
    width: 0px;
  }
}
@media (min-width: 768px) {
  .md\:invisible {
    visibility: hidden;
  }
  .md\:w-0 {
    width: 0px;
  }
}
@media (min-width: 1024px) {
  .lg\:h-auto {
    height: auto;
  }
  .lg\:visible {
    visibility: visible;
  }
  .lg\:w-full {
    width: 100%;
  }
}</style><script type="text/javascript" src="/pagefind/pagefind-ui.js"></script><script type="text/javascript">window.addEventListener('DOMContentLoaded', () => { new PagefindUI({"element":"#search","showImages":false,"showEmptyFilters":true,"resetStyles":false,"bundlePath":"/pagefind/","baseUrl":"/"}); });</script></head>
  <body class="w-full h-full">
    <nav class="flex flex-wrap bg-black text-white h-16 items-center px-4 gap-y-4 gap-x-8 navbar">
      <a href="/">
        <strong class="text-lg heading">bmzcodez.dev</strong>
      </a>

      <div class="max-w-3xl ml-auto w-0 sm:w-0 md:w-0 lg:w-full h-0 lg:h-auto invisible sm:invisible md:invisible lg:visible grow">
        <div id="search"></div>
      </div>
    </nav>

    <main class="body-post">
      <article class="post" data-pagefind-body="">
  <div class="flex flex-col items-center p-8">
    <h1 class="text-2xl font-bold leading-10 tracking-tight text">
      Generating PDF from HTML with JavaScript
    </h1>
    <nav class="post-tags">
      
        <a href="/tags/pdf/" class="p-2 tag-bg">pdf</a>
      
        <a href="/tags/puppeteer/" class="p-2 tag-bg">puppeteer</a>
      
        <a href="/tags/pdf from html/" class="p-2 tag-bg">pdf from html</a>
      
        <a href="/tags/docker/" class="p-2 tag-bg">docker</a>
      
    </nav>

    <time class="p-1" datetime="2020-01-04 01:00:00">
      January 4th, 2020
    </time>
    <article class="mt-10 w-full post-body" id="main">
      <p><strong>In this article I’m going to show how you can generate a PDF document from a heavily styled React page using Puppeteer, headless Chrome &amp; Docker.</strong></p>
<p>Background: A few months ago one of our clients asked us to develop a feature where the user would be able to request a React page in PDF format. That page is basically a report/result for patients with data visualization, containing a lot of SVGs. Furthermore, there were some special requests to manipulate the layout and make some rearrangements of the HTML elements. So the PDF should have different styling and additions compared to the original React page.</p>
<p>As the assignment was a bit more complex than what could have been solved with simple CSS rules, we first explored possible implementations. Essentially we found 3 main solutions. This blogpost will walk you through on these possibilities and the final implementations.</p>
<p>A personal comment before we get started: it’s quite a hassle, so buckle up!</p>
<h2>Table of contents</h2>
<p>Client/Backend side
Option 1: Screenshot from the DOM
Option 2: Use only a PDF library
Final option 3: Puppeteer, headless Chrome
Using Puppeteer with Docker
Option 3 +1: CSS print rules
Summary</p>
<h2>Client side vs Backend</h2>
<p>It is possible to generate a PDF file both on the client-side and on the server-side. However, it probably makes more sense to let the backend handle it, as you don’t want to use up all the resources the user’s browser can offer.</p>
<p>Even so, I’ll still show solutions for both methods.</p>
<h2>Option 1: Make a screenshot from the DOM</h2>
<p>At first sight, this solution seemed to be the simplest, and it turned out to be true, but it has its own limitations. If you don’t have special needs, like selectable or searchable text in the PDF, it is a good and simple way to generate one.</p>
<p>This method is plain and simple: create a screenshot from the page, and put it in a PDF file. Pretty straightforward. We used two packages for this approach:</p>
<p><a href="https://html2canvas.hertzen.com/">Html2canvas</a>, to make a screenshot from the DOM
<a href="https://github.com/MrRio/jsPDF">jsPdf</a>, a library to generate PDF</p>
<p>Let’s start coding.</p>
<pre><code class="language-bash hljs">npm install html2canvas jspdf
</code></pre>
<pre><code class="language-js hljs language-javascript"><span class="hljs-keyword">import</span> html2canvas <span class="hljs-keyword">from</span> <span class="hljs-string">'html2canvas'</span>
<span class="hljs-keyword">import</span> jsPdf <span class="hljs-keyword">from</span> <span class="hljs-string">'jspdf'</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">printPDF</span> () {
    <span class="hljs-keyword">const</span> domElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'your-id'</span>)
    <span class="hljs-title function_">html2canvas</span>(domElement, { <span class="hljs-attr">onclone</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-variable language_">document</span></span>) =&gt;</span> {
      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'print-button'</span>).<span class="hljs-property">style</span>.<span class="hljs-property">visibility</span> = <span class="hljs-string">'hidden'</span>
}})
    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">canvas</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> img = canvas.<span class="hljs-title function_">toDataURL</span>(<span class="hljs-string">'image/png'</span>)
        <span class="hljs-keyword">const</span> pdf = <span class="hljs-keyword">new</span> <span class="hljs-title function_">jsPdf</span>()
        pdf.<span class="hljs-title function_">addImage</span>(imgData, <span class="hljs-string">'JPEG'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height)
        pdf.<span class="hljs-title function_">save</span>(<span class="hljs-string">'your-filename.pdf'</span>)
})
</code></pre>
<p>And that’s it!</p>
<p>Make sure you take a look at the <code>html2canvas</code> <code>onclone</code> method. It can prove to be handy when you quickly need to take a snapshot and manipulate the DOM (e.g. hide the print button) before taking the picture. I can see quite a lot of use cases for this package. Unfortunately, ours wasn’t one, as we needed to handle the PDF creation on the backend side.</p>
<h2>Option 2: Use only a PDF library</h2>
<p>There are several libraries out there on NPM for this purpose, like jsPDF (mentioned above) or <a href="https://www.npmjs.com/package/pdfkit">PDFKit</a>. The problem with them that I would have to recreate the page structure again if I wanted to use these libraries. That definitely hurts maintainability, as I would have needed to apply all subsequent changes to both the PDF template and the React page.</p>
<p>Take a look at the code below. You need to create the PDF document yourself by hand. Now you could traverse the DOM and figure out how to translate each element to PDF ones, but that is a tedious job. There must be an easier way.</p>
<pre><code class="language-js hljs language-javascript">doc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PDFDocument</span>()
doc.<span class="hljs-property">pipe</span> fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'output.pdf'</span>)
doc.<span class="hljs-title function_">font</span>(<span class="hljs-string">'fonts/PalatinoBold.ttf'</span>)
   .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">25</span>)
   .<span class="hljs-title function_">text</span>(<span class="hljs-string">'Some text with an embedded font!'</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>)

doc.<span class="hljs-title function_">image</span>(<span class="hljs-string">'path/to/image.png'</span>, {
   <span class="hljs-attr">fit</span>: [<span class="hljs-number">250</span>, <span class="hljs-number">300</span>],
   <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>,
   <span class="hljs-attr">valign</span>: <span class="hljs-string">'center'</span>
});

doc.<span class="hljs-title function_">addPage</span>()
   .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">25</span>)
   .<span class="hljs-title function_">text</span>(<span class="hljs-string">'Here is some vector graphics...'</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>)

doc.<span class="hljs-title function_">end</span>()
</code></pre>
<p>This snippet is from the PDFKit docs. However, it can be useful if your target is a PDF file straight away and not the conversion of an already existing (and ever-changing) HTML page.</p>
<h2>Final Option 3: Puppeteer</h2>
<h3>What is <a href="https://github.com/GoogleChrome/puppeteer">Puppeteer</a>?</h3>
<p>The documentation says ‘Puppeteer is a Node library which provides a high-level API to control Chrome or Chromium over the DevTools Protocol. Puppeteer runs headless by default, but can be configured to run full (non-headless) Chrome or Chromium’.</p>
<p>It’s basically a browser which you can run from Node.js. If you read the docs, the first thing it says about Puppeteer is that you can use it to <strong>Generate screenshots and PDFs of pages</strong>’. Excellent! That’s what we were looking for.</p>
<p>Let’s install Puppeteer, and implement our use case.</p>
<pre><code class="language-bash hljs">$ npm i puppeteer
</code></pre>
<pre><code class="language-js hljs language-javascript"><span class="hljs-keyword">const</span> puppeteer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'puppeteer'</span>)

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">printPDF</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> browser = <span class="hljs-keyword">await</span> puppeteer.<span class="hljs-title function_">launch</span>({ <span class="hljs-attr">headless</span>: <span class="hljs-literal">true</span> });
  <span class="hljs-keyword">const</span> page = <span class="hljs-keyword">await</span> browser.<span class="hljs-title function_">newPage</span>();
  <span class="hljs-keyword">await</span> page.<span class="hljs-title function_">goto</span>(<span class="hljs-string">'https://blog.risingstack.com'</span>, {<span class="hljs-attr">waitUntil</span>: <span class="hljs-string">'networkidle0'</span>});
  <span class="hljs-keyword">const</span> pdf = <span class="hljs-keyword">await</span> page.<span class="hljs-title function_">pdf</span>({ <span class="hljs-attr">format</span>: <span class="hljs-string">'A4'</span> });

  <span class="hljs-keyword">await</span> browser.<span class="hljs-title function_">close</span>();
  <span class="hljs-keyword">return</span> pdf
})
</code></pre>
<p>This is a simple function that navigates to a URL and generates a PDF file of the site.</p>
<p>First, we launch the browser (PDF generation only supported in headless mode), then we open a new page, set the viewport, and navigate to the provided URL.</p>
<p>Setting the<code>waitUntil: ‘networkidle0’</code>option means, that Puppeteer considers navigation to be finished when there are no network connections for at least 500 ms. (Check <a href="https://github.com/GoogleChrome/puppeteer/blob/v1.11.0/docs/api.md">API docs</a> for further information.)</p>
<p>After that, we save the PDF to a variable, we close the browser and return the PDF.</p>
<p>Note: The <code>page.pdf</code>method receives an <code>options</code> object, where you can save the file to disk with the ‘path’ option as well. If path is not provided, the PDF won’t be saved to the disk, you’ll get a buffer instead. Later on, I discuss how you can handle it.)</p>
<p>In case you need to log in first to generate a PDF from a protected page, first you need to navigate to the login page, inspect the form elements for ID or name, fill them in, then submit the form:</p>
<pre><code class="language-js hljs language-javascript"><span class="hljs-keyword">await</span> page.<span class="hljs-title function_">type</span>(<span class="hljs-string">'#email'</span>, process.<span class="hljs-property">env</span>.<span class="hljs-property">PDF_USER</span>)
<span class="hljs-keyword">await</span> page.<span class="hljs-title function_">type</span>(<span class="hljs-string">'#password'</span>, process.<span class="hljs-property">env</span>.<span class="hljs-property">PDF_PASSWORD</span>)
<span class="hljs-keyword">await</span> page.<span class="hljs-title function_">click</span>(<span class="hljs-string">'#submit'</span>)
</code></pre>
<p><strong>Nb. Always store login credentials in environment variables, do not hardcode them!</strong></p>
<h3>Style manipulation</h3>
<p>Puppeteer has a solution for this style manipulation too. You can insert style tags before generating the PDF, and Puppeteer will generate a file with the modified styles.</p>
<pre><code class="language-css hljs">await page<span class="hljs-selector-class">.addStyleTag</span>({ <span class="hljs-attribute">content</span>: <span class="hljs-string">'.nav { display: none} .navbar { border: 0px} #print-button {display: none}'</span> })
</code></pre>
<h3>Send file to the client and save it</h3>
<p>Okay, now you have generated a PDF file on the backend. What to do now?</p>
<p>As I mentioned above, if you don’t save the file to disk, you’ll get a buffer. You just need to send that buffer with the proper content type to the front-end.</p>
<pre><code class="language-js hljs language-javascript">printPDF.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">pdf</span> =&gt;</span> {
	res.<span class="hljs-title function_">set</span>({ <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/pdf'</span>, <span class="hljs-string">'Content-Length'</span>: pdf.<span class="hljs-property">length</span> })
	res.<span class="hljs-title function_">send</span>(pdf)
</code></pre>
<p>Now you can simply send a request to the server, to get the generated PDF.</p>
<pre><code class="language-js hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getPDF</span>(<span class="hljs-params"></span>) {
 <span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">`<span class="hljs-subst">${API_URL}</span>/your-pdf-endpoint`</span>, {
   <span class="hljs-attr">responseType</span>: <span class="hljs-string">'arraybuffer'</span>,
   <span class="hljs-attr">headers</span>: {
     <span class="hljs-string">'Accept'</span>: <span class="hljs-string">'application/pdf'</span>
   }
 })
</code></pre>
<p>Once you’ve sent the request, the buffer should start downloading. Now the last step is to convert the buffer into a PDF file.</p>
<pre><code class="language-js hljs language-javascript">savePDF = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">openModal</span>(‘<span class="hljs-title class_">Loading</span>…’) <span class="hljs-comment">// open modal</span>
   <span class="hljs-keyword">return</span> <span class="hljs-title function_">getPDF</span>() <span class="hljs-comment">// API call</span>
     .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
       <span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([response.<span class="hljs-property">data</span>], {<span class="hljs-attr">type</span>: <span class="hljs-string">'application/pdf'</span>})
       <span class="hljs-keyword">const</span> link = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'a'</span>)
       link.<span class="hljs-property">href</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">createObjectURL</span>(blob)
       link.<span class="hljs-property">download</span> = <span class="hljs-string">`your-file-name.pdf`</span>
       link.<span class="hljs-title function_">click</span>()
       <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">closeModal</span>() <span class="hljs-comment">// close modal</span>
     })
   .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-comment">/** error handling **/</span>)
 }
</code></pre>
<pre><code class="language-js hljs language-javascript">&lt;button onClick={<span class="hljs-variable language_">this</span>.<span class="hljs-property">savePDF</span>}&gt;<span class="hljs-title class_">Save</span> <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">PDF</span>&lt;/button&gt;
</code></pre>
<p>That was it! If you click on the save button, the PDF will be saved by the browser.</p>
<h2>Usage with Docker</h2>
<p>I think this is the trickiest part of the implementation - so let me save you a couple of hours of Googling.</p>
<p>The official documentation states that <em>“getting headless Chrome up and running in Docker can be tricky”</em>. The official docs have a <a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/troubleshooting.md#running-puppeteer-in-docker">Troubleshooting</a> section, where at the time of writing you can find all the necessary information on installing puppeteer with Docker.</p>
<p>If you install Puppeteer on the Alpine image, make sure you scroll down a bit to <a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/troubleshooting.md#running-on-alpine">this part of the page</a>. Otherwise, you might gloss over the fact that you cannot run the latest Puppeteer version and you also need to disable shm usage, using a flag:</p>
<pre><code class="language-js hljs language-javascript"><span class="hljs-keyword">const</span> browser = <span class="hljs-keyword">await</span> puppeteer.<span class="hljs-title function_">launch</span>({
  <span class="hljs-attr">headless</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">args</span>: [<span class="hljs-string">'--disable-dev-shm-usage'</span>],
})
</code></pre>
<p>Otherwise, the Puppeteer sub process might run out of memory before it even gets started properly. More info about that on the troubleshooting link above.</p>
<h2>Option 3 + 1: CSS print rules</h2>
<p>One might think that simply using CSS print rules is easy from a developers standpoint. No NPM modules, just pure CSS. But how do they fare when it comes to cross-browser compatibility?</p>
<p>When choosing CSS print rules, you have to test the outcome in every browser to make sure it provides the same layout, and it’s not 100% that it does.</p>
<p>For example, inserting a break after a given element cannot be considered an esoteric use case, yet you might be surprised that you need to use workarounds <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/break-after#Browser_compatibility">to get that working in Firefox</a>.</p>
<p>Unless you are a battle-hardened CSS magician with a lot of experience in creating printable pages, this can be time-consuming.</p>
<p>Print rules are great if you can keep the print stylesheets simple.</p>
<p>Let’s see an example.</p>
<pre><code class="language-css hljs"><span class="hljs-keyword">@media</span> print {
  <span class="hljs-selector-class">.print-button</span> {
    <span class="hljs-attribute">display</span>: none;
  }

  <span class="hljs-selector-class">.content</span> <span class="hljs-selector-tag">div</span> {
    <span class="hljs-attribute">break-after</span>: always;
  }
}
</code></pre>
<p>This CSS above hides the print button, and inserts a page break after every <code>div</code> with the class <code>content.</code> There is a <a href="https://www.smashingmagazine.com/2018/05/print-stylesheets-in-2018/">great article</a> that summarizes what you can do with print rules, and what are the difficulties with them including browser compatibility.</p>
<p>Taking everything into account, CSS print rules are great and effective if you want to make a PDF from a not so complex page.</p>
<h2>Summary</h2>
<p>So let’s quickly go through the options we covered here for generating PDF files from HTML pages:</p>
<p><strong>Screenshot from the DOM</strong>: This can be useful when you need to create snapshots from a page (for example to create a thumbnail), but falls short when you have a lot of data to handle.
<strong>Use only a PDF library</strong>: If you need to create PDF files programmatically from scratch, this is a perfect solution. Otherwise, you need to maintain the HTML and PDF templates which is definitely a no-go.
<strong>Puppeteer</strong>: Despite being relatively difficult to get it working on Docker, it provided the best result for our use case, and it was also the easiest to write the code with.
<strong>CSS print rules</strong>: If your users are educated enough to know how to print to a file and your pages are relatively simple, it can be the most painless solution. As you saw in our case, it wasn’t.</p>
<p>Happy printing!</p>

    </article>
  </div>



</article>

<hr>

<nav class="post-navigation">
<ul>
    <li>
      ← Previous: <a href="/posts/learn-javascript-for-free/" rel="prev">Learn JavaScript for free</a>
    </li>
  
    <li>
      <strong>Next: <a href="/posts/hugo-static-site/" rel="next">Static site with Hugo + Netlify deploy</a> →</strong>
    </li>
  
</ul>
</nav>

    </main>

    <footer></footer>

    <!-- Current page: /posts/pdf-from-html-javascript/ -->
  

</body></html>